name: Semantic Release with AI Notes

on:
  workflow_call:
    inputs:
      bun-version:
        type: string
        required: false
        default: "latest"
      service-name:
        type: string
        required: true
        description: "The name of the service to release"
      publish-npm:
        type: string
        required: false
        default: "false"
        description: "Whether to publish to npm"
      prerelease:
        type: string
        required: false
        default: "false"
        description: "Whether to create a prerelease"
    secrets:
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key for determining version and generating release notes"
      NPM_TOKEN:
        required: false
        description: "NPM token for publishing"

jobs:
  check-release-label:
    name: Check for Release Label
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      should_release: ${{ steps.check-label.outputs.has_release_label }}
    steps:
      - name: Check for release label on PR
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            // If triggered by pull_request event, use the PR number directly
            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              const labels = pr.labels.map(l => l.name.toLowerCase());
              
              if (labels.includes('release')) {
                console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
                core.setOutput('has_release_label', 'true');
              } else {
                console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
                console.log(`Current labels: ${labels.join(', ') || 'none'}`);
                core.setOutput('has_release_label', 'false');
              }
              return;
            }
            
            // For push events, find PR for this branch
            const currentRef = context.ref;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${currentRef.replace('refs/heads/', '')}`,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping release.');
              core.setOutput('has_release_label', 'false');
              return;
            }
            
            const pr = prs[0];
            const labels = pr.labels.map(l => l.name.toLowerCase());

  get-release-info:
    name: Get Release Info
    runs-on: ubuntu-latest
    needs: check-release-label
    if: needs.check-release-label.outputs.should_release == 'true'
    permissions:
      contents: read
    outputs:
      sha: ${{ steps.last-release.outputs.sha }}
      version: ${{ steps.last-release.outputs.version }}
      tag: ${{ steps.last-release.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest release SHA
        id: last-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                const tagName = releases[0].tag_name;
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                core.setOutput('sha', ref.object.sha);
                core.setOutput('tag', tagName);
                core.setOutput('version', tagName.replace(/^v/, '')); // Remove 'v' prefix if present
              } else {
                // No releases exist, use initial commit
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 1,
                  sha: 'HEAD'
                });
                if (commits.length > 0) {
                  // Get the first commit (oldest)
                  const allCommits = await github.paginate(github.rest.repos.listCommits, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 100
                  });
                  const firstCommit = allCommits[allCommits.length - 1];
                  core.setOutput('sha', firstCommit.sha);
                  core.setOutput('version', '0.0.0');
                } else {
                  core.setOutput('sha', context.sha);
                  core.setOutput('version', '0.0.0');
                }
              }
            } catch (error) {
              core.setOutput('sha', context.sha);
              core.setOutput('version', '0.0.0');
            }

  ai-determine-version:
    name: AI Determine Version
    runs-on: ubuntu-latest
    needs: get-release-info
    permissions:
      contents: read
    outputs:
      should_release: ${{ steps.parse-version.outputs.should_release }}
      next_version: ${{ steps.parse-version.outputs.next_version }}
      final_version: ${{ steps.final-version.outputs.final_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: AI Determine new release version
        id: ai-version
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            Analyze commits and determine next semantic version.
            Current Version: ${{ needs.get-release-info.outputs.version }}
            Last Release SHA: ${{ needs.get-release-info.outputs.sha }}
            Current SHA: ${{ github.sha }}
            
            Rules:
            - BREAKING CHANGE or ! = major bump
            - feat: = minor bump
            - fix: or perf: = patch bump
            
            Respond with ONLY X.Y.Z or "none".

      - name: Parse AI version response
        id: parse-version
        run: |
          AI_RESPONSE="${{ steps.ai-version.outputs.final-message }}"
          
          # Extract version number (X.Y.Z format) or check for "none"
          if echo "$AI_RESPONSE" | grep -qiE "none|skip|no release"; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "next_version=none" >> $GITHUB_OUTPUT
          else
            # Extract version number (format: X.Y.Z)
            NEXT_VERSION=$(echo "$AI_RESPONSE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            
            if [ -z "$NEXT_VERSION" ]; then
              echo "::error::AI did not return a valid version number. Response: $AI_RESPONSE"
              exit 1
            fi
            
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Apply prerelease tag
        id: final-version
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          BASE_VERSION="${{ steps.parse-version.outputs.next_version }}"
          
          if [ "${{ inputs.prerelease }}" == "true" ]; then
            # Append prerelease suffix
            FINAL_VERSION="${BASE_VERSION}-rc.${GITHUB_RUN_NUMBER}"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating prerelease: $FINAL_VERSION"
          else
            FINAL_VERSION="$BASE_VERSION"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating release: $FINAL_VERSION"
          fi

  ai-generate-notes:
    name: AI Generate Release Notes
    runs-on: ubuntu-latest
    needs: [get-release-info, ai-determine-version]
    if: needs.ai-determine-version.outputs.should_release == 'true'
    permissions:
      contents: read
    outputs:
      release_notes: ${{ steps.ai-notes.outputs.final-message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate AI Release Notes
        id: ai-notes
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            Generate release notes in markdown. NO title. Start with content directly.
            
            Service: ${{ inputs.service-name }}
            Version: ${{ needs.get-release-info.outputs.version }} â†’ ${{ needs.ai-determine-version.outputs.final_version }}
            Current SHA: ${{ github.sha }}
            Last Release SHA: ${{ needs.get-release-info.outputs.sha }}
            
            REQUIREMENTS:
            1. NO title - Start directly with content
            2. Use plain language - Write like explaining to a friend
            3. Keep it SHORT - 1-2 sentences per item max
            4. Group logically - Use headers: ## New Features, ## Bug Fixes, ## Improvements
            5. Only include breaking changes if they exist
            6. NO commit SHA or diff sections
            7. Use emojis SPARINGLY - 1-2 total, prefer people emojis (ðŸ™‹â€â™€ï¸ðŸ™‹â€â™‚ï¸ðŸ‘‹)
            8. Be friendly and engaging

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [get-release-info, ai-determine-version, ai-generate-notes]
    if: needs.ai-determine-version.outputs.should_release == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Install dependencies
        run: bun install

      - name: Prepare release body
        id: release-body
        env:
          AI_NOTES: ${{ needs.ai-generate-notes.outputs.release_notes }}
        run: |
          # Build body with AI notes
          printf '%s\n' "$AI_NOTES" > /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "---" >> /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "**Version:** ${{ needs.get-release-info.outputs.version }} â†’ ${{ needs.ai-determine-version.outputs.final_version }}" >> /tmp/body.txt
          
          # Write to output using multiline format
          {
            echo "body<<BODY_EOF"
            cat /tmp/body.txt
            echo "BODY_EOF"
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.ai-determine-version.outputs.final_version }}
          name: ${{ inputs.service-name }} v${{ needs.ai-determine-version.outputs.final_version }}
          body: ${{ steps.release-body.outputs.body }}
          draft: false
          prerelease: ${{ inputs.prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish:
    name: Publish to NPM
    runs-on: ubuntu-latest
    needs: create-release
    if: inputs.publish-npm == 'true' && inputs.prerelease != 'true'
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: bun install

      - name: Build
        run: bun run build

      - name: Publish to npm
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
