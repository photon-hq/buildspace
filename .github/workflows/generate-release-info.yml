name: Generate Release Info

on:
  workflow_call:
    inputs:
      service-name:
        type: string
        required: true
        description: "The name of the service (used in release notes)"
      prerelease:
        type: boolean
        required: false
        default: false
        description: "Whether this is a prerelease (appends -rc.N suffix)"
    outputs:
      version:
        description: "The determined version (e.g., 1.2.3 or 1.2.3-rc.5)"
        value: ${{ jobs.generate.outputs.version }}
      release_notes:
        description: "AI-generated release notes in markdown"
        value: ${{ jobs.generate.outputs.release_notes }}
    secrets:
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key for AI-powered version detection and notes"

jobs:
  generate:
    name: Generate Version & Notes
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      version: ${{ steps.version.outputs.final }}
      release_notes: ${{ steps.ai-notes.outputs.final-message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Get last release info
        id: last-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                const tagName = releases[0].tag_name;
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                core.setOutput('sha', ref.object.sha);
                core.setOutput('version', tagName.replace(/^v/, ''));
              } else {
                const allCommits = await github.paginate(github.rest.repos.listCommits, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 100
                });
                core.setOutput('sha', allCommits[allCommits.length - 1].sha);
                core.setOutput('version', '0.0.0');
              }
            } catch (error) {
              core.setOutput('sha', context.sha);
              core.setOutput('version', '0.0.0');
            }

      - name: AI Determine Version
        id: ai-version
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          safety-strategy: read-only
          prompt: |
            Analyze commits between ${{ steps.last-release.outputs.sha }} and ${{ github.sha }}.
            Current version: ${{ steps.last-release.outputs.version }}
            Prerelease: ${{ inputs.prerelease }}
            
            Rules:
            - BREAKING CHANGE or ! = major bump
            - feat: = minor bump  
            - fix:, perf:, or other = patch bump
            - Default to patch if unclear
            - For prereleases: use same version logic, suffix will be added automatically
            
            Respond with ONLY X.Y.Z

      - name: Parse Version
        id: version
        run: |
          NEXT=$(echo "${{ steps.ai-version.outputs.final-message }}" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
          [ -z "$NEXT" ] && { echo "::error::Invalid version"; exit 1; }
          
          if [ "${{ inputs.prerelease }}" == "true" ]; then
            echo "final=${NEXT}-rc.${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
          else
            echo "final=${NEXT}" >> $GITHUB_OUTPUT
          fi

      - name: AI Generate Notes
        id: ai-notes
        uses: openai/codex-action@v1
        with:
          prompt: |
            Generate release notes for ${{ inputs.service-name }} v${{ steps.version.outputs.final }}.
            Changes from ${{ steps.last-release.outputs.sha }} to ${{ github.sha }}.
            
            REQUIREMENTS:
            1. NO title - start with content directly
            2. Plain language - like explaining to a friend
            3. SHORT - 1-2 sentences per item
            4. Group: ## New Features, ## Bug Fixes, ## Improvements
            5. Only include breaking changes if they exist
            6. NO commit SHAs
            7. 1-2 emojis max for personality
